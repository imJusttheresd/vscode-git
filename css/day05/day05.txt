 -----------------------------------------------------------------------------------------------
  
  * position (위치지정방식)
    
         static: 기본값(일반적인 위치지정 방식)
         relative: static + 내 자신을 기준(상대적) + 지정 요소

         absolute: 가장 가까운 지정 요소에 대해 상대적으로 배치
         단, 지정 요소가 없다면 body,html을 기준으로 배치

         fixed: 뷰포트(사용자 화면) 기준으로 베치

         sticky: fixed + relative, 가장 가까운 스크롤이되는 조상과
         표 관련 요소 기준으로 지정한 값이 넘으면 마치 fixed처럼 화면에 고정

         => 내가 정해준 기준 넘으면 fixed로 전환

 -----------------------------------------------------------------------------------------------


  :root 선택자(<html>요소의 선택자)

        :root 명시도 및 우선순위가 더 높다는 점만 제외하면 html을 태그 선택으로
        선택한 것과 똑같습니다.

        :root 전역 css 변수(저장) 선언에 유용하게 사용할 수 있습니다.

        ex) :root {
            --저장명: css속성 값
        }


   media qurey(미디어 쿼리)

        단말기의 유형에 따라 해상도(화면크기)는 다릅니다.
        따라서 어떤 특성이나 수치(뷰포트, 해상도) 등에 따라서
        다른 css를 보여줘야만 사용자가 어떠한 환경에서라도 나의 애플리케이션을
        이용이 가능
        => 데스크탑 화면, 모바일 화면, 태블릿 화면

        all (모든 장치)
        print (인쇄 결과물 미리보기)
        * screen (화면)
        speech (음성 합성 장치)

    ex) @media 유형 (속성: 값) and (속성: 값) {
        ... CSS 속성
    } 

        @media screen (max-width:1680px) {
            #container {
                ...CSS 속성
            }
        }

-----------------------------------------------------------------------------------------------

  그리드 레이아웃

    표 형태의 레이아웃
    내가 원하는 크기만큼 요소의 크기를 수정할 수 있음
    그러나 대부분 flex로 해결가능하기 때문에
    grid layout을 자주 사용하지는 않는 편
    그러나 사용해야만 하는 부분이 있음

    따라서 flexible layout + grid layout을 
    적절히 사용해주는 것이 제일 좋음
   
-----------------------------------------------------------------------------------------------
 
  다음주
  1일차 transform, transition, animation, gradation [... CSS 끝]
  2일차 실전 퍼블리싱 ( 로그인, 회원가입, 존윅 )
  3,4일차: 협업 시스템 ( 동료 학습 코드 컨벤션, 깃허브 컨벤션 )

----------------------------------------------------------------------------------------------